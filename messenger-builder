#!/usr/bin/env python3
import argparse
import subprocess
import sys
import os
import importlib
import importlib.util

from pathlib import Path

from messenger import BANNER

LANG_MODULES = ("python", "csharp", "nodejs", "ruby")

def status(msg: str):
    print(f"[status] {msg}")

def update_submodules(branch="main"):
    repo_path = Path.cwd()
    commands = [
        ["git", "submodule", "sync", "--recursive"],
        ["git", "submodule", "update", "--init", "--recursive"],
        ["git", "submodule", "foreach", "--recursive", f"git checkout {branch} && git pull"],
    ]
    for cmd in commands:
        subprocess.run(cmd, cwd=repo_path, check=True)

def in_git_repo_root() -> bool:
    """
    Returns True only if:
    - we're inside a git repo, AND
    - the current working directory is the repo root (contains .git folder)
    """
    return (
        os.path.isdir(".git") and
        subprocess.run(
            ["git", "rev-parse", "--is-inside-work-tree"],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE
        ).returncode == 0
    )

def try_import_builder(lang: str):
    """
    Try importing the builder module for a given language.

    - First tries normal import (works when installed as a package)
    - Falls back to a relative import from ./builder/clients if running from source
    """
    module_name = f"builder.clients.{lang}.builder"

    try:
        return importlib.import_module(module_name)
    except ModuleNotFoundError:
        # fallback: relative path when running directly from repo
        local_path = Path(__file__).resolve().parent / "builder" / "clients" / lang
        builder_file = local_path / "builder.py"
        if builder_file.exists():
            spec = importlib.util.spec_from_file_location(module_name, builder_file)
            mod = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(mod)
            return mod
        return None

def attach_language_subparser(subparsers, lang: str, mod):
    sp = subparsers.add_parser(lang, help=f"Build {lang} client")
    if not hasattr(mod, "add_arguments") or not callable(mod.add_arguments):
        raise SystemExit(f"'{lang}' builder missing add_arguments(subparser)")
    mod.add_arguments(sp)

    if not hasattr(mod, "build") or not callable(mod.build):
        raise SystemExit(f"'{lang}' builder missing build(args)")

    sp.set_defaults(func=lambda args, _mod=mod: _mod.build(args))

def discover_and_register_languages(subparsers):
    available = {}
    for lang in LANG_MODULES:
        mod = try_import_builder(lang)
        if mod:
            attach_language_subparser(subparsers, lang, mod)
            available[lang] = mod
    return available

def main(banner):
    if len(sys.argv) > 1 and sys.argv[1] == 'update-clients':
        if in_git_repo_root():
            update_submodules("main")
        else:
            print("[!] 'update-clients' is only available in the git source directory.")
            print("    (pipx or pip installs will not have the .git folder)")
        sys.exit(0)

    if BANNER:
        print(banner)

    parser = argparse.ArgumentParser(
        prog="messenger-cli",
        formatter_class=argparse.RawTextHelpFormatter,
        usage=argparse.SUPPRESS
    )

    subparsers = parser.add_subparsers(dest="language", required=True)
    available = discover_and_register_languages(subparsers)

    args = parser.parse_args()

    if not hasattr(args, "func"):
        found = ", ".join(sorted(available.keys())) or "none"
        raise SystemExit(f"No language handler bound. Discovered: {found}")

    try:
        artifact = args.func(args)  # NOTE: passes argparse.Namespace directly
        status("Build complete.")
        if artifact:
            status(f"Artifact: {artifact}")
    except KeyboardInterrupt:
        print("\rBuild canceled.")
    except Exception as e:
        status(f"Build failed: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main(BANNER)
